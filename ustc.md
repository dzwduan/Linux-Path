## 1 排序复杂度

<img src="C:\Users\10184\Desktop\Linux-Path\ustc.assets\image-20200322185347141.png" alt="image-20200322185347141" style="zoom:50%;" />



## 3 堆排序

是指利用[堆](https://zh.wikipedia.org/wiki/堆_(数据结构))这种数据结构所设计的一种[排序算法](https://zh.wikipedia.org/wiki/排序算法)。堆是一个近似[完全二叉树](https://zh.wikipedia.org/wiki/完全二叉树)的结构，并同时满足**堆积的性质**：即子节点的键值或索引总是小于（或者大于）它的父节点。

方法：

**a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;**

**b.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;**

**c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。**

堆排序 与 快排的不同

堆排序交换次数多，比快排慢，但是如果求topK之类的，可以快速找到最值，并且空间复杂度也比快排小

另一个场景是优先队列，适合堆排序

快排的有点是整体排序更快，堆排比较的几乎都不是相邻元素，对cache极不友好，这才是很少被采用的原因。

补充


链接：https://www.zhihu.com/question/23873747/answer/327295185

因为堆排序下，数据读取的开销变大。在计算机进行运算的时候，数据不一定会从内存读取出来，而是从一种叫cache的存储单位读取。原因是cache相比内存，读取速度非常快，所以cache会把一部分我们经常读取的数据暂时储存起来，以便下一次读取的时候，可以不必跑到内存去读，而是直接在cache里面找。
一般认为读取数据遵从两个原则：temporal locality，也就是不久前读取过的一个数据，在之后很可能还会被读取一遍；另一个叫spatial locality，也就是说读取一个数据，在它周围内存地址存储的数据也很有可能被读取到。因此，在读取一个单位的数据(比如1个word)之后，不光单个word会被存入cache，与之内存地址相邻的几个word，都会以一个block为单位存入cache中。另外，cache相比内存小得多，当cache满了之后，会将旧的数据剔除，将新的数据覆盖上去。
在进行堆排序的过程中，由于我们要比较一个数组前一半和后一半的数字的大小，而当数组比较长的时候，这前一半和后一半的数据相隔比较远，这就导致了经常在cache里面找不到要读取的数据，需要从内存中读出来，而当cache满了之后，以前读取的数据又要被剔除。
简而言之快排和堆排读取arr[i]这个元素的平均时间是不一样的



## 4. 循环队列的顺序表示中为什么要空一个位置

判断队空和队满的情况





## 5.什么是二叉查找树，原理

二叉查找树要么是一棵空树，要么是一棵具有如下性质的非空二叉树：

1. 若左子树非空，则左子树上的所有结点的关键字值均小于根结点的关键字值。
2. 若右子树非空，则右子树上的所有结点的关键字值均大于根结点的关键字值。
3. 左、右子树本身也分别是一棵二叉查找树（二叉排序树）。

可以看出，二叉查找树是一个递归的数据结构，且对二叉查找树进行中序遍历，可以得到一个**递增**的有序序列。

## .什么是哈希冲突，及如何解决

散列表的装填因子定义为：α = 填入表中的元素个数 / 散列表的长度

α是散列表装满程度的标志因子。由于表长是定值，α与填入表中的元素个数成正比

所以，α越大，填入表中的元素较多，产生冲突的可能性就越大；α越小，填入表中的元素较少，产生冲突的可能性就越小。

定义：

哈希函数也叫散列函数，它对不同的输出值得到一个固定长度的消息摘要。理想的哈希函数对于不同的输入应该产生不同的结构，同时散列结果应当具有同一性（输出值尽量均匀）和雪崩效应（微小的输入值变化使得输出值发生巨大的变化）。

现实中的哈希函数不是完美的，当两个不同的输入值对应一个输出值时，就会产生“碰撞”，这个时候便需要解决冲突。

常见的冲突解决方法有开放定址法，链地址法，建立公共溢出区等。实际的哈希表实现中，使用最多的是链地址法



## .DFS　BFS

深度优先，则是以深度为准则，先一条路走到底，直到达到目标。这里称之为递归下去。

否则既没有达到目标又无路可走了，那么则退回到上一步的状态，走其他路。这便是回溯上来。



广度优先搜索较之深度优先搜索之不同在于，深度优先搜索旨在不管有多少条岔路，先一条路走到底，不成功就返回上一个路口然后就选择下一条岔路，而广度优先搜索旨在面临一个路口时，把所有的岔路口都记下来，然后选择其中一个进入，然后将它的分路情况记录下来，然后再返回来进入另外一个岔路，并重复这样的操作

