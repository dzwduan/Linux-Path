## 1. :: .

> 1、A.B则A为对象或者结构体；
>
> 2、A->B则A为指针，->是成员提取，A->B是提取A中的成员B，A只能是指向类、结构、联合的指针；
>
> 3、::是作用域运算符，A::B表示作用域A中的名称B，A可以是名字空间、类、结构；
>
> 4、：一般用来表示继承；

## 2. .obj

> *.obj:是目标文件,源程序编译后的产物

## 3.继承方式

> 特征	               公有继承	                         保护继承	                        私有继承
> 公有成员变成	**派生类的公有成员**	           **派生类的保护成员**	          **派生类的私有成员**
> 保护成员变成	派生类的保护成员	           派生类的保护成员	          派生类的私有成员
> 私有成员变成	只能通过基类的接口访问	只能通过基类的接口访问	只能通过基类的接口访问
> 能否隐式向上转换	是	                             是（但只能在派生类中）	否
>

## 4.拷贝构造

> A (A& a);						//拷贝构造函数 
>
> A (const A& a);					//拷贝构造函数 
>
> A& operator= (const A& a);		//赋值构造函数

## 5.运算符重载

> 下面是不可重载的运算符列表：
>
> - **.**：成员访问运算符
> - **.\***, **->\***：成员指针访问运算符
> - **::**：域运算符
> - **sizeof**：长度运算符
> - **?:**：条件运算符
> - **#**： 预处理符号

## 6.基类和派生类指针的相互赋值和转换

> 在公有派生的情况下，派生类的[指针](http://c.biancheng.net/c/80/)可以直接赋值给基类指针。但即便基类指针指向的是一个派生类的对象，也不能通过基类指针访问基类没有而派生类中有的成员。
>
> 基类的指针不能赋值给派生类的指针。但是通过强制类型转换，也可以将基类指针强制转换成派生类指针后再赋值给派生类指针。只是在这种情况下，程序员需要保证被转换的基类指针本来就指向一个派生类的对象，这样才是安全的，否则很容易出错。

## 7.成员函数 内联函数

> 成员函数可以在类体内定义，也可以在类体外定义，所以成员函数不一定都是内联函数
>
> 语句过多不宜声明

## 8.静态成员函数 初始化

> 类中的 static 变量是属于类的，不属于某个对象，它在整个程序的运行过程中只有一个副本，因此不能在定义对象时 对变量进行初始化，就是不能用构造函数进行初始化，其正确的初始化方法是：
>
> ```c
> 数据类型 类名::静态数据成员名=值；
> ```

## 9.动态联编

> 在c++中的动态联编是通过虚函数来实现，但在调用时 ， 必须用引用、指针才能实现动态联编、

## 10.初始化顺序

> ```c++
> class C :  public A, public B {
>   D d;// 只根据声明顺序
>  }
> ```
>
> 则初始化的顺序是A, B, D, C的构造函数. 这里基类的初始化顺序是按照声明的顺序, 成员对象也是按照声明的顺序. 因此 c(int i, int j) : B(i), A(j) {} //这里成员初始化列表的顺序是不起作用的。
>
> 析构函数的顺序则刚好是调过来

## 11.动态对象

> new , delete建立释放

## 12.友元类

> 友元关系单向
>
> A是B的友元，友元类A的成员函数可以访问类 B 的所有成员 
>
> 派生类可以继承基类的成员，但是派生类不能继承基类的友元。即基类的友元在访问派生类成员时不具有特殊性，而派生类的友元也不能随意访问基类的成员

## 13.虚基类

> 用于解决二义性问题，详见http://c.biancheng.net/view/2280.html ，虚基类比派生类中的优先级更高
>
> **class** B: **virtual** **public** A{ } //虚继承
>
> 

## 14.this指针

> 只有类的非静态成员才有。
>
> 静态成员可以看作全局数据，不可以和this绑定

## 15.虚函数

> https://www.jianshu.com/p/d07e0ac0ba3c?from=singlemessage
>
> 定义在基类，子类和可以选择性的对其进行覆盖
>
> 虚函数具有继承性，类中跟基类虚函数同名且形参表一样的函数都默认为虚函数
>
> 虚函数需要报错参数类型一致

## 16.虚函数

> 在派生类中重新定义虚函数时，参数类型必须与基类保持一致

## 17.const

> const不能修饰类

## 18.类模板

> 编译器从类模板可以自动生成多个类

## 19.多态性

> **虚函数是实现包含多态的基础**

## 20.辨析

> ## int *&p
>
> 从右往左结合，&p是一个引用， *（&p）是一个指针，int *&p是指向一个int型的指针的引用；
>
> ## int &*p
>
> 从右往左结合，*p是一个指针，&（*p）是一个引用，int &*p是指向一个int型引用的指针，但是引用本身不是一个对象，因此不能指向引用的指针。

## 21.iomanip

> iomanip的作用:
> 主要是对cin,cout之类的一些操纵运算子，比如setfill,setw,setbase,setprecision等等。它是I/O流控制头文件,就像C里面的格式化输出一样。

## 22.形参实参

> 形参是实参的备份
>
> https://www.zhihu.com/question/364869941

## 23.权限

> private：
> 私有控制符。这类成员只能被本类中的成员函数和类的友元函数访问。
>
> protected： 
> 受保护控制符。这类成员可以被本类中的成员函数和类的友元函数访问，也可以被派生类的成员函数和派生类的友元函数访问。 
>
> public： 
> 共有控制符。这类成员可以被本类中的成员函数和类的友元函数访问，也可以被类作用域内的其他函数引用。 

## 24.static

> 为何static成员函数不能为virtual
>
> 1. static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。
> 2. 静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有this指针。
>
> 为何static成员函数不能为const函数
> 当声明一个非静态成员函数为const时，对this指针会有影响。对于一个Test类中的const修饰的成员函数，this指针相当于Test const *, 而对于非const成员函数，this指针相当于Test *.
> 而static成员函数没有this指针，所以使用const来修饰static成员函数没有任何意义。
> volatile的道理也是如此。



## 模拟一错题集 p35开始

> 2.决定C++语言中函数的返回值类型的是（） 
>
> A. return语句中的表达式类型 
>
> B. 调用该函数时系统随机产生的类型
>
>  C. 调用该函数时的主调用函数类型
>
>  D. 在定义该函数时所指定的数据类型 

> 3. 下面叙述不正确的是（） 
>
>    A. 派生类一般都用公有派生 
>
>    B. 对基类成员的访问必须是无二义性的 
>
>    C. 赋值兼容规则也适用于多重继承的组合 
>
>    D. 基类的公有成员在派生类中仍然是公有的 

>  8.所谓多态性是指 （）
>
>  A. 不同的对象调用不同名称的函数
>
>  B. 不同的对象调用相同名称的函数 
>
>  C. 一个对象调用不同名称的函数
>
>  D. 一个对象调用不同名称的对象 

> C++的流库预定义了4个流，它们是cin、cout、clog和___。 
>
>  C++语言支持的两种多态性分别是编译时的多态性和___的多态性
>
> 定义类动态对象数组时，元素只能靠自动调用该类的___来进行初始化



志p41



牛客网刷题

![img](C:\Users\10184\Desktop\Linux-Path\Cpp题库笔记.assets\S(Z(FNS{ZHID$Z[C7TT)2ZV.png)



因为默认以ios_base::out的方式打开文件，所以错误

![image-20200330193335607](C:\Users\10184\Desktop\Linux-Path\Cpp题库笔记.assets\image-20200330193335607.png)

![img](https://uploadfiles.nowcoder.com/images/20190821/5956690_1566380790221_B1433EF6A9095306FAA69EA5A46E3F66)